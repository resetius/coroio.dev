\doxysection{NNet\+::TZero\+Copy\+Line\+Splitter Class Reference}
\hypertarget{struct_n_net_1_1_t_zero_copy_line_splitter}{}\label{struct_n_net_1_1_t_zero_copy_line_splitter}\index{NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}}


Splits incoming data into lines using a fixed-\/size circular buffer, enabling zero-\/copy writes via \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}{Acquire()} and \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353}{Commit()}.  




{\ttfamily \#include $<$sockutils.\+hpp$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_n_net_1_1_t_zero_copy_line_splitter_af64b01796eb016cca29c41a39cb85de3}{TZero\+Copy\+Line\+Splitter}} (int max\+Len)
\begin{DoxyCompactList}\small\item\em Constructs a zero-\/copy line splitter with a fixed ring buffer capacity. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_n_net_1_1_t_line}{TLine}} \mbox{\hyperlink{struct_n_net_1_1_t_zero_copy_line_splitter_a1e1578720d20f66e7a1d6a05cbab7d73}{Pop}} ()
\begin{DoxyCompactList}\small\item\em Extracts and removes the next complete line from the buffer, if available. \end{DoxyCompactList}\item 
std\+::span$<$ char $>$ \mbox{\hyperlink{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}{Acquire}} (size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Reserves space in the circular buffer for writing data directly (e.\+g., from a socket read) without extra copying. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353}{Commit}} (size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Finalizes the amount of data written into the span returned by \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}{Acquire()}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_n_net_1_1_t_zero_copy_line_splitter_a4f342c7968fc6559a7103db01503b248}{Push}} (const char \texorpdfstring{$\ast$}{*}p, size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em (Optional) Copies data from an external buffer into the circular buffer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Splits incoming data into lines using a fixed-\/size circular buffer, enabling zero-\/copy writes via \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}{Acquire()} and \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353}{Commit()}. 

This class maintains a ring buffer of maximum length ({\ttfamily max\+Len}) where new data can be placed without extra copying. To add data, a typical workflow would be\+:
\begin{DoxyEnumerate}
\item Call \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}{Acquire()} to get a {\ttfamily std\+::span$<$char$>$} in the internal buffer.
\item Write directly into that span (e.\+g., using your socket\textquotesingle{}s {\ttfamily read} or {\ttfamily Read\+Some}).
\item Call \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353}{Commit()} with the number of bytes actually written.
\end{DoxyEnumerate}

Lines can then be extracted using \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_a1e1578720d20f66e7a1d6a05cbab7d73}{Pop()}, which returns a {\ttfamily \doxylink{struct_n_net_1_1_t_line}{TLine}} holding up to two string-\/view segments if the line crosses the buffer boundary.\hypertarget{struct_n_net_1_1_t_zero_copy_line_splitter_autotoc_md7}{}\doxysubsubsubsection{\texorpdfstring{Zero-\/\+Copy Example (Reading from a Socket)}{Zero-\/\+Copy Example (Reading from a Socket)}}\label{struct_n_net_1_1_t_zero_copy_line_splitter_autotoc_md7}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Example\ function\ that\ reads\ lines\ from\ a\ socket\ into\ TZeroCopyLineSplitter}}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ ReadLinesFromSocket(TSocket\&\ socket)\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct_n_net_1_1_t_zero_copy_line_splitter_af64b01796eb016cca29c41a39cb85de3}{TZeroCopyLineSplitter}}\ splitter(1024);\ \textcolor{comment}{//\ ring\ buffer\ up\ to\ 1024\ bytes}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Acquire\ a\ chunk\ of\ the\ buffer\ (say\ 256\ bytes)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ span\ =\ splitter.Acquire(256);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (span.empty())\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Not\ enough\ space\ left\ -\/\ handle\ as\ needed\ (e.g.,\ flush\ or\ error)}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Read\ directly\ into\ the\ splitter's\ internal\ buffer}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ssize\_t\ bytesRead\ =\ socket.ReadSome(span.data(),\ span.size());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (bytesRead\ <=\ 0)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ 0\ =>\ socket\ closed,\ negative\ =>\ error}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Commit\ the\ data\ we\ actually\ wrote}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ splitter.Commit(bytesRead);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Now\ try\ popping\ lines}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (\textcolor{keyword}{true})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ TLine\ line\ =\ splitter.Pop();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (line.Part1.empty()\ \&\&\ line.Part2.empty())\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ No\ complete\ line\ available\ at\ the\ moment}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Process\ the\ line\ (Part1\ +\ Part2)...}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{struct_n_net_1_1_t_zero_copy_line_splitter_af64b01796eb016cca29c41a39cb85de3}\index{NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}!TZeroCopyLineSplitter@{TZeroCopyLineSplitter}}
\index{TZeroCopyLineSplitter@{TZeroCopyLineSplitter}!NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}}
\doxysubsubsection{\texorpdfstring{TZeroCopyLineSplitter()}{TZeroCopyLineSplitter()}}
{\footnotesize\ttfamily \label{struct_n_net_1_1_t_zero_copy_line_splitter_af64b01796eb016cca29c41a39cb85de3} 
NNet\+::\+TZero\+Copy\+Line\+Splitter\+::\+TZero\+Copy\+Line\+Splitter (\begin{DoxyParamCaption}\item[{int}]{max\+Len}{}\end{DoxyParamCaption})}



Constructs a zero-\/copy line splitter with a fixed ring buffer capacity. 


\begin{DoxyParams}{Parameters}
{\em max\+Len} & The maximum number of bytes the buffer can hold. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}\index{NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}!Acquire@{Acquire}}
\index{Acquire@{Acquire}!NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}}
\doxysubsubsection{\texorpdfstring{Acquire()}{Acquire()}}
{\footnotesize\ttfamily \label{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465} 
std\+::span$<$ char $>$ NNet\+::\+TZero\+Copy\+Line\+Splitter\+::\+Acquire (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size}{}\end{DoxyParamCaption})}



Reserves space in the circular buffer for writing data directly (e.\+g., from a socket read) without extra copying. 

This method returns a contiguous block of available space as a {\ttfamily std\+::span$<$char$>$}. If the ring buffer wraps around, you might only get the block up to the end; you can call \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}{Acquire()} again for any remaining space, depending on your logic.


\begin{DoxyParams}{Parameters}
{\em size} & The desired number of bytes to acquire. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A {\ttfamily std\+::span$<$char$>$} pointing to the ring buffer region where data can be written. Its size might be less than requested if there\textquotesingle{}s less contiguous space available.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
You must call \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353}{Commit()} after writing into this span, specifying how many bytes were actually written. Otherwise, the new data won\textquotesingle{}t be recognized by the splitter. 
\end{DoxyNote}
\Hypertarget{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353}\index{NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}!Commit@{Commit}}
\index{Commit@{Commit}!NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}}
\doxysubsubsection{\texorpdfstring{Commit()}{Commit()}}
{\footnotesize\ttfamily \label{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353} 
void NNet\+::\+TZero\+Copy\+Line\+Splitter\+::\+Commit (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size}{}\end{DoxyParamCaption})}



Finalizes the amount of data written into the span returned by \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}{Acquire()}. 


\begin{DoxyParams}{Parameters}
{\em size} & The number of bytes that were actually written into the acquired buffer.\\
\hline
\end{DoxyParams}
After calling {\ttfamily \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353}{Commit()}}, this new data is considered part of the buffer and can be used to form lines via \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_a1e1578720d20f66e7a1d6a05cbab7d73}{Pop()}. \Hypertarget{struct_n_net_1_1_t_zero_copy_line_splitter_a1e1578720d20f66e7a1d6a05cbab7d73}\index{NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}!Pop@{Pop}}
\index{Pop@{Pop}!NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}}
\doxysubsubsection{\texorpdfstring{Pop()}{Pop()}}
{\footnotesize\ttfamily \label{struct_n_net_1_1_t_zero_copy_line_splitter_a1e1578720d20f66e7a1d6a05cbab7d73} 
\mbox{\hyperlink{struct_n_net_1_1_t_line}{TLine}} NNet\+::\+TZero\+Copy\+Line\+Splitter\+::\+Pop (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Extracts and removes the next complete line from the buffer, if available. 

A line is typically delimited by a newline character (implementation-\/specific). If the line crosses the circular boundary, the returned {\ttfamily \doxylink{struct_n_net_1_1_t_line}{TLine}} will contain two segments ({\ttfamily Part1} and {\ttfamily Part2}).

\begin{DoxyReturn}{Returns}
A {\ttfamily \doxylink{struct_n_net_1_1_t_line}{TLine}} object with up to two {\ttfamily std\+::string\+\_\+view} segments referencing the internal ring buffer. If there is no complete line available, behavior is implementation-\/defined (it may return an empty {\ttfamily \doxylink{struct_n_net_1_1_t_line}{TLine}} or throw an exception).
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
The returned string views become invalid once additional data is acquired, committed, or popped. Keep this in mind if you need to store the line contents for later use. 
\end{DoxyWarning}
\Hypertarget{struct_n_net_1_1_t_zero_copy_line_splitter_a4f342c7968fc6559a7103db01503b248}\index{NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}!Push@{Push}}
\index{Push@{Push}!NNet::TZeroCopyLineSplitter@{NNet::TZeroCopyLineSplitter}}
\doxysubsubsection{\texorpdfstring{Push()}{Push()}}
{\footnotesize\ttfamily \label{struct_n_net_1_1_t_zero_copy_line_splitter_a4f342c7968fc6559a7103db01503b248} 
void NNet\+::\+TZero\+Copy\+Line\+Splitter\+::\+Push (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{p}{, }\item[{size\+\_\+t}]{len}{}\end{DoxyParamCaption})}



(Optional) Copies data from an external buffer into the circular buffer. 

While the main purpose of this class is zero-\/copy insertion via \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_ae046dcda237bb388211cc3227dfe1465}{Acquire()} and \doxylink{struct_n_net_1_1_t_zero_copy_line_splitter_abb13941bdde48ab6559a79149ac66353}{Commit()}, this method offers a fallback for situations where you already have data in a separate buffer and wish to write it into the splitter in one call.


\begin{DoxyParams}{Parameters}
{\em p} & Pointer to the data to copy from. \\
\hline
{\em len} & Number of bytes to copy. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
coroio/sockutils.\+hpp\end{DoxyCompactItemize}
